'use strict';

const aws = require('aws-sdk');
const https = require('https');
const url = require('url');

var rekognition,
    kinesisdata,
    kinesisvideo;

function initServices() {
    aws.config.update({ region: process.env.AWS_REGION });
    rekognition = new aws.Rekognition();
    kinesisdata = new aws.Kinesis();
    kinesisvideo = new aws.KinesisVideo();
}
initServices();

// Creates a Kinesis Video Stream and Rekognition Stream Processor when CloudFormation stack is created.
// Rekognition Stream Processor detects positions of faces in streaming video.
// Input of Rekognition Stream Processor is the KVS.
// Output of Rekognition Stream Processor is a KDS.
// By default, an empty face collection is used to initialize the stream processor.
function createStreamResources(cb) {
    var streamResources = {};

    function getOrCreateKDS() {
        return new Promise(function(resolve, reject) {
            const KDS_STREAM_NAME = process.env.KDS_RAW_STREAM_NAME;
            // Check if KDS exists
            kinesisdata.describeStream({
                StreamName: KDS_STREAM_NAME
            }, function(err, data) {
                if (data) return resolve(data);
                // Stream does not exist
                console.log("Creating Kinesis Data Stream: " + KDS_STREAM_NAME);
                return kinesisdata.createStream({
                    StreamName: KDS_STREAM_NAME,
                    ShardCount: 1
                }, function(err, data) {
                    if (err) return reject(err);
                    kinesisdata.describeStream({
                        StreamName: KDS_STREAM_NAME
                    }, function(err, data) {
                        return err ? reject(err) : resolve(data);
                    });
                });
            });
        });
    }

    function getOrCreateKVS() {
        const KVS_STREAM_NAME = process.env.KVS_STREAM_NAME;
        return new Promise(function(resolve, reject) {
            // Check if KVS exists
            kinesisvideo.describeStream({
                StreamName: KVS_STREAM_NAME
            }, function(err, data) {
                if (data) return resolve(data);
                // Stream does not exist
                console.log("Creating Kinesis Video Stream: " + KVS_STREAM_NAME);
                return kinesisvideo.createStream({
                    StreamName: KVS_STREAM_NAME,
                    DataRetentionInHours: 24,
                    MediaType: 'video/h264'
                }, function(err, data) {
                    if (err) return reject(err);
                    kinesisvideo.describeStream({
                        StreamName: KVS_STREAM_NAME
                    }, function(err, data) {
                        return err ? reject(err) : resolve(data);
                    });
                });
            });
        });
    }

    function getOrCreateRekStreamProcessor() {
        const STREAM_PROCESSOR_NAME = process.env.REK_STREAM_PROCESSOR_NAME;
        return new Promise(function(resolve, reject) {
            // Check if Stream processor exists
            rekognition.describeStreamProcessor({
                Name: STREAM_PROCESSOR_NAME
            }, function(err, data) {
                if (data) return resolve(data);
                // Stream processor does not exist
                console.log("Creating Rekognition stream processor: " + STREAM_PROCESSOR_NAME);
                return rekognition.createStreamProcessor({
                    Input: { KinesisVideoStream: { Arn: streamResources.KVS.StreamARN } },
                    Output: { KinesisDataStream: { Arn: streamResources.KDS.StreamARN } },
                    Name: STREAM_PROCESSOR_NAME,
                    RoleArn: process.env.REK_ROLE_ARN,
                    Settings: { FaceSearch: { FaceMatchThreshold: process.env.REK_FACE_MATCH_THRESHOLD || 90, CollectionId: process.env.REK_FACE_COLLECTION } }
                }, function(err, data) {
                    if (err) return reject(err);
                    rekognition.describeStreamProcessor({
                        Name: STREAM_PROCESSOR_NAME
                    }, function(err, data){
                       return err ? reject(err) : resolve(data);
                    });
                });
            });
        });
    }

    getOrCreateKVS().then(function(data) {
        streamResources.KVS = data.StreamInfo;
        getOrCreateKDS().then(function(data) {
            streamResources.KDS = data.StreamDescription;
            rekognition.createCollection({
                CollectionId: process.env.REK_FACE_COLLECTION
            }, function(err, data) {
              getOrCreateRekStreamProcessor().then(function(data) {
                streamResources.RekStreamProcessor = data;
                rekognition.startStreamProcessor({
                    Name: streamResources.RekStreamProcessor.Name
                }, function(err, data) {
                    if (err) {
                        console.log(err);
                    }
                    cb(null, streamResources);
                });
              }).catch(cb);
            });
        }).catch(cb);
    }).catch(cb);
}

// Deletes all stream resources when stack is deleted.
function deleteStreamResources(cb) {

    function deleteStreamProcessor() {
        return new Promise(function(resolve) {
            rekognition.stopStreamProcessor({
                Name: process.env.REK_STREAM_PROCESSOR_NAME
            }, function(err, data) {
                if (data) {
                    console.log("Stopped Rekognition stream processor");
                }
                rekognition.deleteStreamProcessor({
                        Name: process.env.REK_STREAM_PROCESSOR_NAME
                }, function(err, data) {
                    if (data) {
                        console.log("Deleted Rekognition stream processor");
                    }
                    rekognition.deleteCollection({
                        CollectionId: process.env.REK_FACE_COLLECTION
                    }, function(err, data) {
                        if (data) {
                            console.log("Deleted Face Collection");
                        }
                        resolve();
                    });
                });
            });
        });
    }

    function deleteKVS() {
        return new Promise(function(resolve) {
            kinesisvideo.describeStream({
                StreamName: process.env.KVS_STREAM_NAME
            }, function(err, data) {
                if (data && data.StreamInfo) {
                    kinesisvideo.deleteStream({
                        StreamARN: data.StreamInfo.StreamARN
                    }, function(err, _data) {
                        if (_data) {
                            console.log("Deleted KVS: " + data.StreamInfo.StreamARN);
                        }
                        resolve();
                    });
                } else {
                    resolve();
                }
            });
        })
    }

    deleteStreamProcessor().then(function() {
        deleteKVS().then(cb).catch(cb);
    }).catch(cb);
}

// Sends a response to the pre-signed S3 URL
function sendResponse(event, callback, logStreamName, responseStatus, responseData) {
    const responseBody = JSON.stringify({
        Status: responseStatus,
        Reason: `See the details in CloudWatch Log Stream: ${logStreamName}`,
        PhysicalResourceId: logStreamName,
        StackId: event.StackId,
        RequestId: event.RequestId,
        LogicalResourceId: event.LogicalResourceId,
        Data: responseData
    });

    console.log('RESPONSE BODY:\n', responseBody);

    const parsedUrl = url.parse(event.ResponseURL);
    const options = {
        hostname: parsedUrl.hostname,
        port: 443,
        path: parsedUrl.path,
        method: 'PUT',
        headers: {
            'Content-Type': '',
            'Content-Length': responseBody.length,
        },
    };

    const req = https.request(options, (res) => {
        console.log('STATUS:', res.statusCode);
        console.log('HEADERS:', JSON.stringify(res.headers));
        callback(null, 'Successfully sent stack response!');
    });

    req.on('error', (err) => {
        console.log('sendResponse Error:\n', err);
        callback(err);
    });

    req.write(responseBody);
    req.end();
}

exports.handler = (event, context, callback) => {
    try {
        var responseData;
        if (event.RequestType === 'Delete') {
            // Stack is being deleted, tear down all stream resources.
            deleteStreamResources(function(err) {
                if (err) {
                    console.log(err);
                }
                sendResponse(event, callback, context.logStreamName, 'SUCCESS');
            });
            return;
        }
        // Otherwise, stack is being created or updated. Create resources if they do not exist.
        createStreamResources(function(err, resources) {
            if (err) {
                console.log(err);
                responseData = { Error: err };
            } else {
                responseData = { Id: resources.KVS.StreamARN };
            }
            sendResponse(event, callback, context.logStreamName, err ? 'FAILED' : 'SUCCESS', responseData);
        });
    } catch (e) {
        sendResponse(event, callback, context.logStreamName, 'FAILED', { Error: e });
    }
};